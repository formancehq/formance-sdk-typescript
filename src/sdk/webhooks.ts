/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { webhooksActivateConfig } from "../funcs/webhooksActivateConfig.js";
import { webhooksChangeConfigSecret } from "../funcs/webhooksChangeConfigSecret.js";
import { webhooksDeactivateConfig } from "../funcs/webhooksDeactivateConfig.js";
import { webhooksDeleteConfig } from "../funcs/webhooksDeleteConfig.js";
import { webhooksGetManyConfigs } from "../funcs/webhooksGetManyConfigs.js";
import { webhooksInsertConfig } from "../funcs/webhooksInsertConfig.js";
import { webhooksTestConfig } from "../funcs/webhooksTestConfig.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "./models/operations/index.js";
import * as shared from "./models/shared/index.js";
import { unwrapAsync } from "./types/fp.js";

export class Webhooks extends ClientSDK {
    /**
     * Activate one config
     *
     * @remarks
     * Activate a webhooks config by ID, to start receiving webhooks to its endpoint.
     */
    async activateConfig(
        request: operations.ActivateConfigRequest,
        options?: RequestOptions
    ): Promise<operations.ActivateConfigResponse> {
        return unwrapAsync(webhooksActivateConfig(this, request, options));
    }

    /**
     * Change the signing secret of a config
     *
     * @remarks
     * Change the signing secret of the endpoint of a webhooks config.
     *
     * If not passed or empty, a secret is automatically generated.
     * The format is a random string of bytes of size 24, base64 encoded. (larger size after encoding)
     *
     */
    async changeConfigSecret(
        request: operations.ChangeConfigSecretRequest,
        options?: RequestOptions
    ): Promise<operations.ChangeConfigSecretResponse> {
        return unwrapAsync(webhooksChangeConfigSecret(this, request, options));
    }

    /**
     * Deactivate one config
     *
     * @remarks
     * Deactivate a webhooks config by ID, to stop receiving webhooks to its endpoint.
     */
    async deactivateConfig(
        request: operations.DeactivateConfigRequest,
        options?: RequestOptions
    ): Promise<operations.DeactivateConfigResponse> {
        return unwrapAsync(webhooksDeactivateConfig(this, request, options));
    }

    /**
     * Delete one config
     *
     * @remarks
     * Delete a webhooks config by ID.
     */
    async deleteConfig(
        request: operations.DeleteConfigRequest,
        options?: RequestOptions
    ): Promise<operations.DeleteConfigResponse> {
        return unwrapAsync(webhooksDeleteConfig(this, request, options));
    }

    /**
     * Get many configs
     *
     * @remarks
     * Sorted by updated date descending
     */
    async getManyConfigs(
        request: operations.GetManyConfigsRequest,
        options?: RequestOptions
    ): Promise<operations.GetManyConfigsResponse> {
        return unwrapAsync(webhooksGetManyConfigs(this, request, options));
    }

    /**
     * Insert a new config
     *
     * @remarks
     * Insert a new webhooks config.
     *
     * The endpoint should be a valid https URL and be unique.
     *
     * The secret is the endpoint's verification secret.
     * If not passed or empty, a secret is automatically generated.
     * The format is a random string of bytes of size 24, base64 encoded. (larger size after encoding)
     *
     * All eventTypes are converted to lower-case when inserted.
     *
     */
    async insertConfig(
        request: shared.ConfigUser,
        options?: RequestOptions
    ): Promise<operations.InsertConfigResponse> {
        return unwrapAsync(webhooksInsertConfig(this, request, options));
    }

    /**
     * Test one config
     *
     * @remarks
     * Test a config by sending a webhook to its endpoint.
     */
    async testConfig(
        request: operations.TestConfigRequest,
        options?: RequestOptions
    ): Promise<operations.TestConfigResponse> {
        return unwrapAsync(webhooksTestConfig(this, request, options));
    }
}
